<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="午饭吃啥">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="午饭吃啥">
<meta property="og:locale">
<meta property="article:author" content="dc">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>午饭吃啥</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">午饭吃啥</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">螺蛳粉</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/28/awk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/28/awk/" class="post-title-link" itemprop="url">awk</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-28 10:20:51" itemprop="dateCreated datePublished" datetime="2020-10-28T10:20:51+08:00">2020-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 18:37:52" itemprop="dateModified" datetime="2022-11-15T18:37:52+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>awk命令使用方法</p>
<h1 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h1><p>awk [选项] ’条件{动作}  条件{动作} … …’  文件名 …’}}]</p>
<p>awk语法由一系列条件和动作组成，在花括号内可以有多个动作，在多个动作之间使用分号分隔，在多个条件和动作之间可以有若干空格，也可以没有。awk会逐行扫描以读取文件内容，从第一行到最后一行，寻找与条件匹配的行，并对这些匹配的数据行执行特定的动作。条件可以是正则匹配、数字或字符串比较，动作可以是打印需要过滤的数据或者其他，如果没有指定条件则可以匹配所有数据行，如果没有指定动作则默认为print打印操作。因为awk是逐行处理软件，所以这里的动作默认都隐含着循环，条件被匹配多少次，动作就被执行多少次。</p>
<h1 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h1><p>awk有很多内置变量<br>FILENAME 当前输入文档的名称<br>FNR 当前输入文档的当前行号，尤其当有多个输入文档时有用<br>NR 输入数据流的当前行号<br>$0 当前行的全部数据内容<br>$n… 当前行的第n个字段的内容<br>NF 当前记录的字段个数<br>FS 字段分割符，默认为空格<br>OFS 输出字段分隔符，默认为空格<br>ORS 输出记录分割符，默认为换行符<br>RS 输入记录分割符，默认为换行符</p>
<h1 id="基本命令使用"><a href="#基本命令使用" class="headerlink" title="基本命令使用"></a>基本命令使用</h1><p>free | awk ‘{print $2}}’  逐行打印第二列<br>free | awk ‘{print NR}’ 输出行号<br>free | awk ‘{print NF}’ 输出每行数据的列数<br>awk ‘{print $3}’ test 打印test文件每行第3列<br>awk ‘{print $0}’ test  打印test文件全部内容<br>awk ‘{print}’ test<br>awk ‘{print NF}’ test 打印每行数据的列数<br>awk ‘{print $NF}’ test 打印每行数据的最后一列<br>awk ‘{print FILENAME}’ test 打印文件名</p>
<p>awk可以通过-v（variable）选项设置或者修改变量的值，我们可以使用-v定义新的变量，也可以使用该选项修改内置变量的值。</p>
<p>awd -v x&#x3D;”Jacob” ‘{print x}’ test 定义变量，输出变量值<br>x&#x3D;”hello”                             #自定义系统变量<br>awk -v i&#x3D;$x ‘{print i}’ test1.txt     #awk调用系统变量一</p>
<p>i&#x3D;”hello”                             #定义系统变量<br>awk ‘{print “‘$i’”}’  test1.txt       #awk调用系统变量二</p>
<p>awk -v FS&#x3D;”:” ‘{print $1}’ test    重新定义分隔符为冒号<br>awk -F: ‘{print $1}’ test 定义冒号为字段分隔符<br>awk -v RS&#x3D;”, “ ‘{print $1}’ test 定义以逗号为分隔符<br>awk ‘print $1,12345,$2’ test   print打印数字<br>awk ‘print “{第一列:”$1,”\t第二列:”$2}’ test print打印字符串</p>
<p>awk支持使用正则进行模糊匹配，也支持字符串和数字的精确匹配，并且支持逻辑与和逻辑或<br>awk ‘&#x2F;world&#x2F;{print}’ test  打印包含world的行<br>awk ‘&#x2F;world&#x2F;‘ test 打印包含world的行 当没有动作指令时则默认指令是print打印当前行所有数据内容。awk会逐行读取所有数据，对每行数据都进行正则匹配，匹配到包含word的数据行时则打印全部所有内容<br>awk支持仅对某列进行正则匹配，在两个数据之间进行正则匹配需要使用正则比较符（～）进行匹配比较。<br>awk ‘$2<del>&#x2F;the&#x2F;‘ test 每行第二列正则匹配the<br>awk ‘$3</del>&#x2F;never&#x2F;{print $1, $4, $5}’ test 匹配每一行是否包含never.如果包含则打印该行的1 4 5 列数据<br>awk ‘$4&#x3D;&#x3D;”to”‘ test 第4列精确匹配to<br>awk ‘$2!&#x3D;”the”‘ test 第2列不等于the<br>awk -F: ‘$3&lt;&#x3D;10’ &#x2F;etc&#x2F;passwd<br>awk -F: ‘$3&lt;&#x3D;10{print $1}’ &#x2F;etc&#x2F;passwd 以:为分隔符， 匹配每行第三列小于等于10的列，并打印该行的第一列数据<br>awk ‘NR&#x3D;&#x3D;4’ &#x2F;etc&#x2F;passwd 打印第4行数据内容<br>awk -F: ‘$3&gt;1&amp;&amp;$3&lt;5’ &#x2F;etc&#x2F;passwd  逻辑与，满足两个条件<br> awk的匹配条件可以是BEGIN或END（大写字母）, BEGIN会导致动作指令仅在读取任何数据记录之前执行一次，END会导致动作指令仅在读取完所有数据记录后执行一次。利用BEGIN我们可以进行数据的初始化操作，而END则可以帮助我们进行数据的汇总操作。<br> awk ‘BEGIN{print “OK”}’ BEGIN后面的动作指令，在读取任何数据记录前就被执行且仅执行一次，因此上面的指令不需要通过文件读取任何数据即可执行，如果添加了文件也没有任何影响。<br> awk ‘BEGIN{print “OK”}’ &#x2F;etc&#x2F;passwd  效果同上<br> awk ‘END{print NR}’ &#x2F;etc&#x2F;passwd END后面的动作指令，仅在读取完所有数据流之后被执行一次，NR变量的值为当前行的行号，读取第1行数据时NR的值为1，读取第2行数据时NR的值为2，依此类推。因为END的指令在读取完所有数据行之后才会执行，当读取完所有数据行后NR的值为&#x2F;etc&#x2F;passwd文件最后一行的行号，此时再打印输出18，表示&#x2F;etc&#x2F;passwd文件有18行</p>
<p>awk -F: ‘BEGIN{print “用户名UID 解释器”} {print $1 “-“ $3 “-“ $7} END{print “总计有”NR”个账户.”}’ &#x2F;etc&#x2F;passwd</p>
<p>在awk中变量不需要定义就可以直接使用，作为字符处理时未定义的变量默认值为空，作为数字处理时未定义的变量默认值为0。<br>awk ‘&#x2F;bash$&#x2F;{x++} END{print x}’ &#x2F;etc&#x2F;passwd 账户.”}’ &#x2F;etc&#x2F;passwd 逐行读取&#x2F;etc&#x2F;passwd文件，x初始值为0，匹配以bash结尾的行时执行x++，读取完所有数据行后打印x的值。如果第1行以bash结尾则x++&#x3D;1，如果第2行数据不以bash结尾则跳过，依此类推。</p>
<p> who | awk ‘$1&#x3D;&#x3D;”root”{x++} END{print x}’ 统计root登陆次数<br>seq 200 | awk ‘$1%7&#x3D;&#x3D;0 &amp;&amp; $1~&#x2F;7&#x2F;‘<br>df | tail -n +2 | awk ‘{sum+&#x3D;$4} END{print sum}’<br>ls -l &#x2F;etc&#x2F; * .conf | awk ‘{sum+&#x3D;$5} END{print sum}’<br>ls -l &#x2F;etc | awk ‘&#x2F;^-&#x2F;{sum+&#x3D;$5} END{print “文件总容量:”sum”.”}’</p>
<p>awk 条件判断<br>ps -eo user,pid,pcpu,comm | awk ‘{if ($3&gt;0.5) {print}}’  输出cpu占用大于0.3的行<br>awk -F”[: &#x2F;]” ‘$7”:”$8 &gt;&#x3D; “10:00” &amp;&amp; $7”:”$8 &gt;&#x3D; “10:30”‘ &#x2F;usr&#x2F;nginx.log  首先通过-F定义数据字段的分隔符为冒号、空格或斜线，因此第7列和第8列就对应的是小时和分钟，通过将$7:$8与指定的时间进行对比即可过滤有个时间段内的日志数据。</p>
<p>未完待续。。。。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/05/sed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/05/sed/" class="post-title-link" itemprop="url">sed</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-05 08:44:37" itemprop="dateCreated datePublished" datetime="2020-10-05T08:44:37+08:00">2020-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 18:17:08" itemprop="dateModified" datetime="2022-11-15T18:17:08+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>sed是Linux下一款功能强大的非交互流式文本编辑器，可以对文本文件进行增、删、改、查等操作，支持按行、按字段、按正则匹配文本内容，灵活方便，特别适合于大文件的编辑。<br>sed全称是：Stream EDitor<br>sed在处理文本时是逐行读取文件内容，读到匹配的行就根据指令做操作，不匹配就跳过。</p>
<h1 id="sed基础命令使用"><a href="#sed基础命令使用" class="headerlink" title="sed基础命令使用"></a>sed基础命令使用</h1><p>sed ‘s&#x2F;e&#x2F;E&#x2F;2p’ test.txt<br>仅显示被替换的数据行<br>在s替换指令的最后添加i标记可以忽略大小写</p>
<p>sed ‘s&#x2F;jacob&#x2F;vicky&#x2F;i’ test.txt<br>使用s替换指令时如果同时添加了e标记，则表示将替换后的内容当成Shell命令在终端执行一次</p>
<p>echo ‘&#x2F;etc&#x2F;hosts’ | sed ‘s&#x2F;^&#x2F;ls -l &#x2F;e’<br>将字符串头替换ls -l 并执行命令,将&#x2F;etc&#x2F;hosts替换成ls -l &#x2F;etc&#x2F;hosts .替换后执行该命令</p>
<p>echo “tmpfile” | sed ‘s#^#touch &#x2F;tmp&#x2F;#e’<br>将tmpfile替换为touch &#x2F;tmp&#x2F;tmpfile，替换后在命令终端执行该命令，最后使用ls &#x2F;tmp&#x2F;tmpfile查看系统中是否已经创建了该文件。</p>
<p>sed ‘s&#x2F;the&#x2F;&#x2F;‘ test.txt<br>将the替换为空，即删除</p>
<p>echo ‘“hello” “world”‘ | sed ‘s&#x2F;&quot;. * \ “&#x2F;&#x2F;‘<br>匹配双引号中的所有数据，并将其删除</p>
<p>echo ‘“hello” “world”‘ | sed ‘s&#x2F;&quot;[^&quot;] * &quot;&#x2F;&#x2F;‘<br>在匹配由一个引号开始，中间是不包含引号的任意其他字符（长度任意），最后是一个双引号结束的数据，这样当一行数据中包含多个引号数据时，就可以仅仅匹配第一个双引号的数据。</p>
<p>sed -r ‘s&#x2F;^(.) (.*) (.) $&#x2F;\3\2\1&#x2F;‘ test.txt<br>将每行首尾字符对调<br>上面这条命令应用了正则表达式中的保留功能，使用圆括号将匹配的数据保留，在后面通过\n调用前面保留的数据。这里在第一个圆括号中保留的是每行开头的第一个字符（．在正则中表示任意单个字符），在第三个圆括号中保留的是每行结束的最后一个字符，而在中间第二个圆括号中保留的是除首尾字符外中间的所有字符（.*在正则中表示任意长度的任意字符）。因为都是使用任意字符进行匹配，所以这三个括号可以匹配所有行的数据，并在后面将匹配的数据顺序进行重新调整再输出，将第三个括号的数据（\3）先输出，再输出第二个括号中的数据（\2），最后输出的是第一个括号中的数据（\1）。</p>
<p>sed ‘s&#x2F;/sbin/nologin&#x2F;/bin/sh&#x2F;‘ &#x2F;tmp&#x2F;passwd<br>将&#x2F;sbin&#x2F;nologin 替换成 &#x2F;bin&#x2F;sh   &#x2F;需要使用转义<br>sed ‘s#&#x2F;sbin&#x2F;nologin#&#x2F;bin&#x2F;sh#’ &#x2F;tmp&#x2F;passwd<br> #号作为替换符<br>sed ‘s, &#x2F;sbin&#x2F;nologin, &#x2F;bin&#x2F;sh, ‘ &#x2F;tmp&#x2F;passwd<br> ,号作为替换符</p>
<p>使用sed时可以使用分号或者-e选项两种方式在一行中编写多条指令。可以直接使用分号将多个指令分隔，或者在多个-e参数后面添加sed指令，sed支持一个或多个-e参数。如果将分号放到花括号中还可以实现对指令进行分组。</p>
<p>sed -n ‘1p;3p;5p’ test.txt<br>显示第1,3,5行</p>
<p>sed -n -e ‘1p’ -e ‘3p’ test.txt<br>显示第1,3行</p>
<p>sed ‘2h;5g’ test.txt<br>在读取文件的第2行时将整行数据复制到了保留空间，并将保留空间中原有的回车符覆盖了，然后在读取第5行数据时，使用保留空间中的数据覆盖掉模式空间中的数据</p>
<p>sed ‘2h;5G’ test.txt<br>使用的是大写字母G，是将保留空间中的数据追加到第5行的后<br>sed的正常流程是先读取数据行放入模式空间，然后匹配条件执行sed指令，如果有多个指令，则只有最后一个指令被执行后才会输出模式空间的内容，接着读取文件的下一行内容，依此类推，直到文件读取结束时退出sed程序。但是如果使用n（next）指令，则会改变这样的正常流程，sed遇到n指令会立刻输出当前模式空间中的内容，直接读取输入文件的下一行数据到模式空间。<br>因为没有匹配条件因此指令对所有数据行都有效，先是读取test.txt的第一行到模式空间，然后执行n会导致打印当前行的数据内容（显示第一行hello the world），接着读取文件下一行数据到模式空间（go spurs go），此时再执行d就会将刚刚读取进来的数据删除（删除go spurs go这行），最后当n和d指令都执行完毕了，接着sed继续读取文件下一行数据（读取第3行进入模式空间），依此类推，最终输出的效果就是将偶数行全部删除，屏幕仅显示奇数行的内容。</p>
<p>sed ‘n; d’ test.txt<br>删除偶数行</p>
<p>sed -n ‘2{N; l}’ test.txt<br>当读取test.txt文件的第2行到模式空间后，先使用N读取下一行（第3行）追加到模式空间现有数据的后面，此时模式空间中就有了两行数据，使用l指令可以显示当前模式空间中的数据，并且与p指令不同，使用l指令可以打印出那些不可显示的控制字符，如换行符（\n）或回车符（$）之类的内容。如果使用的是p指令，则不会显示控制字符，而是将控制字符转换为实际的换行和回车符</p>
<p>sed -n ‘N ; s&#x2F;\n&#x2F;&#x2F;‘ test.txt<br>每两行合并为一行</p>
<p>sed支持多种替换操作，c以行为单位替换，s以关键词为单位替换，y以字符为单位替换，单个字符是sed中的最小处理单位。</p>
<p>sed ‘y&#x2F;hg&#x2F;HG&#x2F;‘ test.txt<br>h替换为H g替换为G<br>sed ‘y&#x2F;hg&#x2F;12’ test.txt<br>h替换为1 g替换为2<br>sed ‘y&#x2F;abcdefghijklmnopqrstuvwxy&#x2F;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x2F;‘ test.txt<br>小写替换为大写</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/15/docker%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/15/docker%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">docker命令笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-15 17:38:57" itemprop="dateCreated datePublished" datetime="2020-08-15T17:38:57+08:00">2020-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 17:42:20" itemprop="dateModified" datetime="2022-11-15T17:42:20+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>记录一些Docker命令</p>
<h1 id="docker-命令行中it的意思"><a href="#docker-命令行中it的意思" class="headerlink" title="docker 命令行中it的意思"></a>docker 命令行中it的意思</h1><p>-i：以交互模式运行容器，通常与-t同时使用<br>-d：后台运行容器，并返回容器ID，也即启动守护式容器<br>-t：为容器重新分配一个伪输入终端，通常与-i同时使用</p>
<h1 id="docker-p-111-111"><a href="#docker-p-111-111" class="headerlink" title="docker -p 111:111"></a>docker -p 111:111</h1><p>把dockertcp111端口映射到宿主机的111端口</p>
<h1 id="docker-p-192-168-1-100-8080-80"><a href="#docker-p-192-168-1-100-8080-80" class="headerlink" title="docker -p 192.168.1.100:8080:80"></a>docker -p 192.168.1.100:8080:80</h1><p>将容器的TCP80端口映射到IP地址为192.168.1.100宿主机的8080端口</p>
<h1 id="docker-p-8080-80-x2F-tcp-p-8080-80-x2F-udp"><a href="#docker-p-8080-80-x2F-tcp-p-8080-80-x2F-udp" class="headerlink" title="docker -p 8080:80&#x2F;tcp -p 8080:80&#x2F;udp"></a>docker -p 8080:80&#x2F;tcp -p 8080:80&#x2F;udp</h1><p>同时映射TCP和UDP端口</p>
<h1 id="docker-exec-it-‘id’-bash"><a href="#docker-exec-it-‘id’-bash" class="headerlink" title="docker exec -it ‘id’ bash"></a>docker exec -it ‘id’ bash</h1><p>在容器id中以交互模式启动一个终端</p>
<h1 id="docker-ps-a"><a href="#docker-ps-a" class="headerlink" title="docker ps -a"></a>docker ps -a</h1><p>查看所有的容器</p>
<h1 id="docker-pull-ubuntu"><a href="#docker-pull-ubuntu" class="headerlink" title="docker pull ubuntu"></a>docker pull ubuntu</h1><p>下载ubuntu镜像</p>
<h1 id="docker-run-it-ubuntu-x2F-bin-x2F-bash"><a href="#docker-run-it-ubuntu-x2F-bin-x2F-bash" class="headerlink" title="docker run -it ubuntu &#x2F;bin&#x2F;bash"></a>docker run -it ubuntu &#x2F;bin&#x2F;bash</h1><p>启动ubuntu镜像，参数为以命令行模式进入镜像<br>&#x2F;bin&#x2F;bash 放在镜像后面的是命令，因为用的是交互式shell,所以用的是&#x2F;bin&#x2F;bash</p>
<h1 id="docker-start-container"><a href="#docker-start-container" class="headerlink" title="docker start container"></a>docker start container</h1><p>启动一个已停止的容器</p>
<h1 id="docker-stop-container"><a href="#docker-stop-container" class="headerlink" title="docker stop container"></a>docker stop container</h1><p>停止正在运行的容器</p>
<h1 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h1><p>重启</p>
<h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：<br>docker attach container &#x2F;&#x2F;注意： 如果从这个容器退出，会导致容器的停止。<br>docker exec：推荐使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。</p>
<h1 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h1><p>docker  export ubuntu &gt; ubuntu.rar</p>
<h1 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h1><p>docker import &#x2F;&#x2F;后面可以使url</p>
<h1 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h1><p>docker rm -f container</p>
<h1 id="清理掉所有处于终止状态的容器。"><a href="#清理掉所有处于终止状态的容器。" class="headerlink" title="清理掉所有处于终止状态的容器。"></a>清理掉所有处于终止状态的容器。</h1><p>docker container prune</p>
<h1 id="docker-pull-training-x2F-webapp"><a href="#docker-pull-training-x2F-webapp" class="headerlink" title="docker pull training&#x2F;webapp"></a>docker pull training&#x2F;webapp</h1><p>载入镜像</p>
<h1 id="docker-run-d-P-training-x2F-webapp-python-app-py"><a href="#docker-run-d-P-training-x2F-webapp-python-app-py" class="headerlink" title="docker run -d -P training&#x2F;webapp python app.py"></a>docker run -d -P training&#x2F;webapp python app.py</h1><p>-d:让容器在后台运行。<br>-P:将容器内部使用的网络端口随机映射到我们使用的主机上</p>
<h1 id="docker-port"><a href="#docker-port" class="headerlink" title="docker port"></a>docker port</h1><p>可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p>
<h1 id="导入docker镜像名字为oadocker"><a href="#导入docker镜像名字为oadocker" class="headerlink" title="导入docker镜像名字为oadocker"></a>导入docker镜像名字为oadocker</h1><p>wget -q –show-progress    <a target="_blank" rel="noopener" href="https://wufanchisha.cn/oadocker.rar">https://wufanchisha.cn/oadocker.rar</a><br>docker import oadocker.rar  oadocker<br>rm oadocker.rar<br>docker run -it -p 3888:3888 oadocker &#x2F;bin&#x2F;bash &#x2F;root&#x2F;runnode.sh 1</p>
<h1 id="docker-–privileged-x3D-true"><a href="#docker-–privileged-x3D-true" class="headerlink" title="docker –privileged&#x3D;true"></a>docker –privileged&#x3D;true</h1><p>使用该参数，container内的root拥有真正的root权限。<br>否则，container内的root只是外部的一个普通用户权限。<br>privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。<br>甚至允许你在docker容器中启动docker容器。</p>
<h1 id="docker-–cap-add"><a href="#docker-–cap-add" class="headerlink" title="docker –cap-add"></a>docker –cap-add</h1><p>添加权限<br>属于细粒度权限</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/11/vim%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/vim%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%95/" class="post-title-link" itemprop="url">vim配置清单</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-11 18:06:53" itemprop="dateCreated datePublished" datetime="2020-05-11T18:06:53+08:00">2020-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 18:09:13" itemprop="dateModified" datetime="2022-11-15T18:09:13+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>记录自己使用的vim插件 .vimrc文件<br>拷贝代码粘贴到$HOME&#x2F;.vimrc 即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&quot; 将先导键重新映射为逗号</span><br><span class="line">let mapleader = &quot;\&lt;space&gt;&quot; &quot;建议将先导键映射为空格</span><br><span class="line">syntax on                 &quot; 支持语法高亮显示</span><br><span class="line">filetype plugin indent on &quot; 启用根据文件类型自动缩进</span><br><span class="line">set autoindent            &quot; 开始新行时处理缩进</span><br><span class="line">set expandtab             &quot; 将制表符Tab展开为空格，这对于Python尤其有用</span><br><span class="line">set tabstop=4             &quot; 要计算的空格数</span><br><span class="line">set shiftwidth=4          &quot; 用于自动缩进的空格数</span><br><span class="line">set backspace=2           &quot; 在多数终端上修正退格键Backspace的行为</span><br><span class="line">set hlsearch              &quot; 设置搜索高亮</span><br><span class="line">set incsearch             &quot; 设置动态跳转</span><br><span class="line">colorscheme murphy        &quot; 修改配色</span><br><span class="line">packloadall               &quot; 加载所有插件</span><br><span class="line">silent! helptags ALL      &quot; 为所有插件加载帮助文档</span><br><span class="line">set ignorecase            &quot; 搜索忽略大小写</span><br><span class="line">set tags=tags; &quot; 在父目录中递归查找tags文件 可以在代码文件中执行ctags -R 来生常tags文件</span><br><span class="line">let NERDTreeShowBookmarks = 1 &quot; 启动NERDTree时显示书签</span><br><span class="line">let NERDTreeHijackNetrw = 0</span><br><span class="line">autocmd VimEnter * NERDTree   &quot; Vim启动时打开NERDTree</span><br><span class="line">&quot; 当NERDTree窗口是最后一个窗口时自动关闭</span><br><span class="line">autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp;</span><br><span class="line">  \ b:NERDTree.isTabTree()) | q | endif</span><br><span class="line"></span><br><span class="line">&quot; 设置NERDTREE</span><br><span class="line">map &lt;F3&gt; :NERDTreeMirror&lt;CR&gt;</span><br><span class="line">map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">&quot; 使用&lt;Ctrl&gt;+hjkl快速在窗口间跳转</span><br><span class="line">&quot; noremap 用于非递归映射</span><br><span class="line">&quot; map 用于递归映射</span><br><span class="line">noremap &lt;c-h&gt; &lt;c-w&gt;&lt;c-h&gt;</span><br><span class="line">noremap &lt;c-j&gt; &lt;c-w&gt;&lt;c-j&gt;</span><br><span class="line">noremap &lt;c-k&gt; &lt;c-w&gt;&lt;c-k&gt;</span><br><span class="line">noremap &lt;c-l&gt; &lt;c-w&gt;&lt;c-l&gt;</span><br><span class="line">&quot; 禁止箭头键功能，使自己习惯hjkl风格</span><br><span class="line">map &lt;up&gt; &lt;nop&gt;</span><br><span class="line">map &lt;down&gt; &lt;nop&gt;</span><br><span class="line">map &lt;left&gt; &lt;nop&gt;</span><br><span class="line">map &lt;right&gt; &lt;nop&gt;</span><br><span class="line"></span><br><span class="line">&quot; 在插入模式下加入一对引号或括号</span><br><span class="line">inoremap &#x27; &#x27;&#x27;&lt;esc&gt;i</span><br><span class="line">inoremap &quot; &quot;&quot;&lt;esc&gt;i</span><br><span class="line">inoremap ( ()&lt;esc&gt;i</span><br><span class="line">inoremap &#123; &#123;&#125;&lt;esc&gt;i</span><br><span class="line">inoremap [ []&lt;esc&gt;i</span><br><span class="line"></span><br><span class="line">&quot; 如果没安装过vim-plug，则下载安装</span><br><span class="line">if empty(glob(&#x27;~/.vim/autoload/plug.vim&#x27;))</span><br><span class="line">  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs</span><br><span class="line">     \https://raw.GitHub.com/junegunn/vim-plug/master/plug.vim</span><br><span class="line">  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">&quot; 使用vim-plug管理插件</span><br><span class="line">call plug#begin()</span><br><span class="line">Plug &#x27;scrooloose/nerdtree&#x27;, &#123; &#x27;on&#x27;: &#x27;NERDTreeToggle&#x27; &#125;</span><br><span class="line">Plug &#x27;tpope/vim-vinegar&#x27;</span><br><span class="line">Plug &#x27;ctrlpvim/ctrlp.vim&#x27;</span><br><span class="line">Plug &#x27;mileszs/ack.vim&#x27;</span><br><span class="line">Plug &#x27;easymotion/vim-easymotion&#x27;</span><br><span class="line">Plug &#x27;junegunn/goyo.vim&#x27;, &#123; &#x27;for&#x27;: &#x27;markdown&#x27; &#125; &quot; 只对markdown文件加载</span><br><span class="line">Plug &#x27;junegunn/vim-plug&#x27;</span><br><span class="line">let g:plug_timeout = 300 &quot; 为YouCompleteMe增加vim-plug的超时时间</span><br><span class="line">Plug &#x27;Valloric/YouCompleteMe&#x27;, &#123; &#x27;do&#x27;: &#x27;./install.sh --clangd-completer&#x27; &#125; &quot;自动补全功能</span><br><span class="line">Plug &#x27;sjl/gundo.vim&#x27;</span><br><span class="line">Plug &#x27;tpope/vim-fugitive&#x27;</span><br><span class="line">Plug &#x27;vim-scripts/taglist.vim&#x27; &quot; taglist插件</span><br><span class="line">Plug &#x27;tacahiroy/ctrlp-funky&#x27; &quot; ctrlp funky 模糊搜索当前文件中所有函数</span><br><span class="line"></span><br><span class="line">call plug#end()</span><br><span class="line"></span><br><span class="line">autocmd BufWritePost *.cpp *.h *.c silent! !ctags -R &amp; &quot; 自动更新标签 如果保存了c++/c文件后</span><br><span class="line"></span><br><span class="line">&quot; 设置 tagslist</span><br><span class="line">let Tlist_Use_Right_Window = 1 &quot; 让taglist窗口出现在Vim的右边</span><br><span class="line">let Tlist_File_Fold_Auto_Close = 1 &quot; 当同时显示多个文件中的tag时，设置为1，可使taglist只显示当前文件tag，其它文件的tag都被折叠起来。</span><br><span class="line">let Tlist_Show_One_File = 1 &quot; 只显示一个文件中的tag，默认为显示多个</span><br><span class="line">let Tlist_Sort_Type =&#x27;name&#x27; &quot; Tag的排序规则，以名字排序。默认是以在文件中出现的顺序排序</span><br><span class="line">let Tlist_GainFocus_On_ToggleOpen = 1  &quot;Taglist窗口打开时，立刻切换为有焦点状态</span><br><span class="line">let Tlist_Exit_OnlyWindow = 1 &quot; 如果taglist窗口是最后一个窗口，则退出vim</span><br><span class="line">let Tlist_WinWidth = 45 &quot; 设置窗体宽度为32，可以根据自己喜好设置</span><br><span class="line">map t :TlistToggle&lt;CR&gt; &quot;热键设置</span><br><span class="line"></span><br><span class="line">&quot; cscope</span><br><span class="line">&quot; cs add /home/dc/workspace/wp_qt5/cscope.out</span><br><span class="line">&quot; map &lt;C-\&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; Funky</span><br><span class="line">nnoremap &lt;Leader&gt;fu :CtrlPFunky&lt;Cr&gt;</span><br><span class="line">&quot; narrow the list down with a word under cursor</span><br><span class="line">nnoremap &lt;Leader&gt;uu :execute &#x27;CtrlPFunky &#x27; . expand(&#x27;&lt;cword&gt;&#x27;)&lt;Cr&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/08/23/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/23/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-23 13:14:12" itemprop="dateCreated datePublished" datetime="2019-08-23T13:14:12+08:00">2019-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 17:27:45" itemprop="dateModified" datetime="2022-11-15T17:27:45+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RAII机制"><a href="#RAII机制" class="headerlink" title="RAII机制"></a>RAII机制</h1><p>为了管理内存资源，C++程序员通常采用RAII机制，资源获取即初始化(Resource Acquisition Is Initialization)，在使用资源的类的构造函数中申请资源，然后使用，最终在析构函数中释放资源。</p>
<p>如果对象是用声明的方式在栈上创建的一个局部对象，RAII机制会正常工作，当离开作用域时对象会自动销毁从而调用析构函数释放资源，但如果对象是用new操作符在堆上创建的，那么它的析构函数不会自动调用，必须使用delete操作符销毁才能释放资源。这就存在内存泄漏的隐患，因为这个时候没有任何对象对已经获取的资源负责，如果因为某些意外导致程序未能执行delete，那么内存等资源就永久的丢失，造成内存泄漏。</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>C++中智能指针使用了RAII机制，在退出作用域时，不管是正常流程或是异常退出，总会调用delete来析构堆上动态分配的对象。</p>
<p>C++中存在多种智能指针，包括auto_ptr、unique_ptr、shared_ptr、weak_ptr</p>
<h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>std::auto_ptr是C++98标准中的“自动指针”，目前已经在C++11标准中被声明为弃用，它解决了获取资源自动释放的部分问题，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::auto_ptr&lt;int&gt; p1(new int(8));</span><br><span class="line">std::auto_ptr&lt;new_resource&gt; p(new new_resource);</span><br></pre></td></tr></table></figure>
<p>auto_ptr构造函数接受new 操作符或者对象工厂创造出的对象指针作为参数，从而代理了原始指针，虽然它是一个对象，但是重载了operator*和operator-&gt;，其行为非常类似指针，可以在大多数普通指针可用的地方，退出作用域时会保证auto_ptr对象销毁，调用auto_ptr的析构函数，使用delete操作符删除原始指针释放资源。</p>
<p>虽然auto_ptr很好用，但是还是存在一些缺陷，使用auto_ptr需要注意以下几个问题</p>
<p>auto_ptr 不能指向数组<br>auto_ptr 不能共享所有权<br>auto_ptr 不能通过复制操作来初始化<br>auto_ptr 不能放入容器中使用<br>auto_ptr 不能作为容器的成员<br>不能把一个原生指针给两个智能指针对象管理(对所有的智能指针).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　int* p = new int;</span><br><span class="line">　　std::auto_ptr&lt;int&gt; ap1(p);</span><br><span class="line">　　std::auto_ptr&lt;int&gt; ap2(p); // 错误, p不能给第二个智能指针对象. 会引起两次释放p</span><br></pre></td></tr></table></figure>
<p>C++11&#x2F;14标准中提供了更完善的unique_ptr、shared_ptr、weak_ptr</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr是在C++标准中定义的新的智能指针，用来取代C++98中的std::auto_ptr，unique_ptr不仅能够代理new 创建单个对象，也能够代理new[]创建数组对象。独享被管理对象指针所有权的智能指针，不允许拷贝构造和拷贝赋值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; up(new int);	// 声明一个unique_ptr，管理int指针</span><br><span class="line">*up = 10;	// 使用operator*操作指针</span><br><span class="line">up.release()	//释放其关联的原始指针的所有权，并返回原始指针。这里是释放所有权，并没有delete原始指针</span><br><span class="line">up.reset();	// delete原始指针。，将unique_ptr置为空</span><br></pre></td></tr></table></figure>
<p>unique_ptr只负责作用域内的指针管理工作，不允许转让指针所有权，所以无法通过复制构造函数或赋值运算符创建unique_ptr对象的副本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; up2 = up1;	// 错误，unique_ptr 不能复制</span><br><span class="line">up1 = up2;	// 错误，unique_ptr 不能复制</span><br></pre></td></tr></table></figure>

<p>虽然无法复制unique_ptr对象，但是可以转移对象，这意味着 unique_ptr 对象可以将关联的原始指针的所有权转移到另一个 unique_ptr 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; up1(new int(1));</span><br><span class="line">std::unique_ptr&lt;int&gt; up2 = std::move(up1); //使用move将up1转换为右值引用，调用 unique_ptr 的移动构造函数，并将关联的原始指针传输到up2</span><br><span class="line">assert(up1==nullptr);</span><br><span class="line">assert(up2!=nullptr);</span><br><span class="line">std::cout &lt;&lt; up2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>make_unique<br>C++14增加了对应的工厂函数make_unique()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; up = std::make_unique&lt;int&gt;(34);</span><br><span class="line">auto up = std::make_unique&lt;int&gt;(34);</span><br><span class="line">int *p = up.get();	//获取管理对象的指针</span><br></pre></td></tr></table></figure>

<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr同样是用于管理new动态分配对象的智能指针，因此功能上有很多相似之处，也是重载了*和-&gt;操作符来模仿原始指针的行为，提供显示bool类型转换以判断指针的有效性，get()可以获取原始指针，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; sp(new int);</span><br><span class="line">assert(sp);</span><br><span class="line">assert(sp.unique());	//现在shared_ptr是指针唯一的持有者</span><br><span class="line">*sp = 1;	//使用解引用操作符修改被指对象</span><br><span class="line">shared_ptr&lt;int&gt; sp2 = sp;	//调用拷贝构造函数，指向sp2</span><br><span class="line">assert(sp==sp2 &amp;&amp; sp.use_count() == 2); //指向同一个对象，引用计数为2</span><br><span class="line">sp.reset();		//停止shared_ptr的使用</span><br><span class="line">assert(!sp);	//sp不持有任何指针（空指针）</span><br></pre></td></tr></table></figure>

<p>shared_ptr不同之处在于它是可以被安全共享的，有正常的拷贝，赋值，也可以进行比较，并且一个shared_ptr可以被多个线程安全的读取，是“最智能”的智能指针</p>
<p>make_shared</p>
<p>shared_ptr提供了一个工厂函数，make_shared()来消除显示的new调用;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto sp = std::make_shared&lt;std::string&gt;(&quot;make shared&quot;);	//创建string共享指针</span><br><span class="line">auto sp1 = std::make_sared&lt;std::vector&lt;int&gt; &gt;(10, 2);	//创建vector共享指针</span><br><span class="line">assert(sp1.size() == 10);</span><br></pre></td></tr></table></figure>

<p>除了make_shared()，还有一个allocate_shared()，它比make_shared()多接受一个定制的内存分配器类型参数，其他类型都相同。</p>
<p>应用于标准容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef std::vector&lt;shared_ptr&lt;int&gt; &gt; vs; //一个持有shared_ptr的标准容器类型</span><br><span class="line">vs v(10);	//声明一个拥有10个元素的容器</span><br><span class="line">int i = 0;</span><br><span class="line">for (auto pos = v.begin(); pos != v.end(); ++pos)</span><br><span class="line">&#123;</span><br><span class="line">    (*pos) = std::make_shared&lt;int&gt;(i++);	//使用工厂函数</span><br><span class="line">    std::cout &lt;&lt; *(*pos) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用于桥接模式<br>桥接模式是一种结构型设计模式，它把类的具体实现细节对用户隐藏起来，已达到类之间的最小耦合关系，在具体编程实践中桥接模式也被称为pimpl用法，它可以将头文件的依赖关系讲到最小，减少编译时间，而且不使用虚函数来实现多态可以使用unique_ptr和shared_ptr来实现桥接模式，但是shared_ptr更合适，因为它支持拷贝和赋值，可以配合容器使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class sample</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	class impl;	//内部类声明</span><br><span class="line">	std::shared_ptr&lt;impl&gt; m_pimp; //shared_ptr成员变量</span><br><span class="line">public:</span><br><span class="line">	sample();</span><br><span class="line">	void print();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class sample::impl	//内部类实现</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void print()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;impl print&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">sample::sample()</span><br><span class="line">	:m_pimp(new impl)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">void sample::print()</span><br><span class="line">&#123;</span><br><span class="line">	m_pimp-&gt;print();	//调用pimpl实现print()</span><br><span class="line">&#125;</span><br><span class="line">//使用方法</span><br><span class="line">sample s;</span><br><span class="line">s.print();</span><br></pre></td></tr></table></figure>

<p>桥接模式非常有用，可以改变具体的实现而外界对比一无所知，同时页减少了源文件之间的编译依赖，是程序获得更多的灵活性</p>
<p>应用于工厂模式<br>工厂模式是一种创建型设计模式，该模式封装了new操作符的使用，使对象的创建工作集中在工厂类或工厂函数中，从而更容易适应变化，在我们使用工厂函数时通常需要在堆上使用new动态分配一个对象，然后返回对象的指针，这样做用户很容易忘记对指针调用delete，存在资源泄露的隐患。<br>使用shared_ptr可以解决这个问题，只需要修改工厂方法接口即可，不再返回一个原始指针，返回shared_ptr包装的智能指针，这样做可以很好的保护系统资源，而且更好地控制对接口的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class abstract</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void f() = 0;</span><br><span class="line">	virtual void g() = 0;</span><br><span class="line">protected:</span><br><span class="line">	virtual ~abstract() = default;	//析构函数只能被它自己和它的子类调用，其他任何对象都无权调用</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class impl : public abstract</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	impl() = default;</span><br><span class="line">	virtual ~impl() = default;</span><br><span class="line">public:</span><br><span class="line">	virtual void f()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;class impl f&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void g()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;clas  impl g&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;abstract&gt; create()</span><br><span class="line">&#123;</span><br><span class="line">	return make_shared&lt;impl&gt;();</span><br><span class="line">&#125;</span><br><span class="line">//使用方法</span><br><span class="line">auto p = create();</span><br><span class="line">p-&gt;f();</span><br><span class="line">p-&gt;g();</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr 是为配合shared_ptr而引入的一种智能指针，它更像shared_ptr的助手而不是智能指针，因为它不具有普通指针的行为，没有重载operator和-&gt;,它的最大用处在于协助shared_ptr工作weak_ptr与shared_ptr协同工作，可以从一个shared_ptr或另一个weak_ptr对象构造，*获得资源观测权，但weak_ptr没有共享资源，它的构造不会引起引用计数增加或减少。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> std::shared_ptr&lt;int&gt; sp(new int(10));</span><br><span class="line"> assert(sp.use_count() == 1);</span><br><span class="line"> std::weak_ptr&lt;int&gt; wp(sp);	//通过shared_ptr创建weak_ptr</span><br><span class="line"> assert(wp.use_count() == 1);	//引用计数</span><br><span class="line"> if (!wp.expired())	//判断shared_ptr是否失效</span><br><span class="line"> &#123;</span><br><span class="line">	 std::shared_ptr&lt;int&gt; sp1 = wp.lock();	//获得一个shared_ptr指针</span><br><span class="line">	 *sp1 = 20;</span><br><span class="line">	 assert(sp1.use_count() == 2);</span><br><span class="line"> &#125;	//退出作用域, sp引用计数减1</span><br><span class="line"></span><br><span class="line"> sp.reset();	//shared_ptr失效</span><br><span class="line"> assert(wp.expired());</span><br><span class="line"> assert(!wp.lock());	//获得一个空指针</span><br><span class="line"></span><br><span class="line">QApplication a(argc, argv);</span><br><span class="line">a.setFont(QFont(&quot;Microsoft Yahei&quot;, 9));</span><br></pre></td></tr></table></figure>
<p>应用场景<br>weak_ptr主要用途是获得this指针的shared_ptr，使对象自己能够生产shared_ptr管理自己，对象使用weak_ptr观测this指针，不影响引用计数，在需要的时候调用lock()函数，返回一个符合要求的shared_ptr供外界使用<br>weak_ptr还可以打破循环引用，有些代码中会出现循环引用，这是引用计数就会失效，导致不正确的释放资源，例如一个双向链表，这是就可以使用weak_ptr，因为它不会增加智能指针的引用计数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/08/01/lock-guard%E5%92%8Cunique-lock%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/01/lock-guard%E5%92%8Cunique-lock%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">lock_guard和unique_lock使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-01 11:09:31" itemprop="dateCreated datePublished" datetime="2019-08-01T11:09:31+08:00">2019-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 17:12:45" itemprop="dateModified" datetime="2022-11-15T17:12:45+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h1><p>我们在多线程中保护共享数据时，可以使用std::mutex互斥量来解决，通过实例化std::mutex创建互斥量实例，使用lock()成员函数对互斥量上锁，unlock()进行解锁，但是我们必须在函数出口都要去调用unlock()，包括异常情况，但是毕竟人无完人，总会又忘记得时候，所以C++11提供了一种ARII机制的模板类std::lock_guard，在构造的时候能提供已锁的互斥量，并在析构的时候解锁，从而保证了一个已锁的互斥量能正确被解锁。</p>
<p>这里引用cppreference的例子来说明</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_i = <span class="number">0</span>;</span><br><span class="line">std::mutex g_i_mutex;  <span class="comment">// protects g_i</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用构造函数自动上锁</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    ++g_i;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// g_i_mutex is automatically released when lock</span></span><br><span class="line">    <span class="comment">//退出作用域，自动解锁，即使是抛出异常也会正常解锁   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//main: 0</span></span><br><span class="line"><span class="comment">//140641306900224: 1</span></span><br><span class="line"><span class="comment">//140641298507520: 2</span></span><br><span class="line"><span class="comment">//main: 2</span></span><br></pre></td></tr></table></figure>

<h1 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h1><p>std::unique_lock 为互斥锁管理模板类，std::unique_lock对象以独占所有权打方式管理mutex对象得上锁和解锁操作，即在unique_lock对象得声明周期内，它所管理得锁对象会一直保持上锁状态，当它得生命收起结束以后，它管理得锁会自动解锁,std::unique_lock具有lock_guard得所有功能，而且更为灵活，它是可以移动，所以它可以作为函数得返回值，也可以放到stl容器中，但是需要付出更多的时间、性能成本。。</p>
<p>std::unique_lock还支持同时锁定多个mutex，这避免了多道加锁时的资源”死锁”问题。在使用std::condition_variable时需要使用std::unique_lock而不应该使用std::lock_guard</p>
<p>这里引用cppreference的例子来说明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="comment">//explicit 该关键字修饰构造函数，是构造函数不能使用隐式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Box</span><span class="params">(<span class="type">int</span> num)</span> : num_things&#123;</span>num&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_things;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(Box &amp;from, Box &amp;to, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在这里实际上并没有拿到锁</span></span><br><span class="line">    <span class="comment">//std::defer_lock 这里的作用是延迟加锁，此处只管理mutex</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, std::defer_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //lock一次性锁住多个mutex防止死锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2);</span><br><span class="line"></span><br><span class="line">    from.num_things -= num;</span><br><span class="line">    to.num_things += num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;from.m&#x27; and &#x27;to.m&#x27; mutexes unlocked in &#x27;unique_lock&#x27; dtors</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">acc1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">acc2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"> 	<span class="comment">//std::ref 引用传递</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(transfer, std::ref(acc1), std::ref(acc2), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(transfer, std::ref(acc2), std::ref(acc1), <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配合条件变量(std::condition_variable)一起使用</p>
<p>当 std::condition_variable 对象的某个 wait 函数被调用的时候，它使用 std::unique_lock(通过 std::mutex) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 std::condition_variable 对象上调用了 notification 函数来唤醒当前线程。</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

std::mutex m;
std::condition_variable cv;
std::string data;
bool ready = false;
bool processed = false;

void worker_thread()
&#123;
    // Wait until main() sends data
    std::unique_lock&lt;std::mutex&gt; lk(m);
    cv.wait(lk, []&#123;return ready;&#125;); //如果标志位不为 true, 则等待...
    // 当前线程被阻塞, 当全局标志位变为 true 之后, 线程被唤醒, 继续往下执行打印线程编号id.
     //以下这种写法和上面一致
    while (!ready)
    &#123;
        cv.wait(lck);
    &#125;

    // after the wait, we own the lock.
    std::cout &lt;&lt; &quot;Worker thread is processing data\n&quot;;
    data += &quot; after processing&quot;;

    // Send data back to main()
    processed = true;
    std::cout &lt;&lt; &quot;Worker thread signals data processing completed\n&quot;;

    // Manual unlocking is done before notifying, to avoid waking up
    // the waiting thread only to block again (see notify_one for details)
    lk.unlock();
    cv.notify_one();
&#125;

int main()
&#123;
    std::thread worker(worker_thread);

    data = &quot;Example data&quot;;
    // send data to the worker thread
    &#123;
        std::lock_guard&lt;std::mutex&gt; lk(m);
        ready = true;	//设置标记为为true
        std::cout &lt;&lt; &quot;main() signals data ready for processing\n&quot;;
    &#125;
    cv.notify_one();	//唤醒子线程

    // wait for the worker
    &#123;
        std::unique_lock&lt;std::mutex&gt; lk(m);
        cv.wait(lk, []&#123;return processed;&#125;);
    &#125;
    std::cout &lt;&lt; &quot;Back in main(), data = &quot; &lt;&lt; data &lt;&lt; &#39;\n&#39;;

    worker.join();
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/06/25/QT%E6%BA%90%E7%A0%81%E4%B8%ADd%E6%8C%87%E9%92%88%E3%80%81d-func/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/25/QT%E6%BA%90%E7%A0%81%E4%B8%ADd%E6%8C%87%E9%92%88%E3%80%81d-func/" class="post-title-link" itemprop="url">QT源码中d指针、d_func</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-25 10:06:51" itemprop="dateCreated datePublished" datetime="2019-06-25T10:06:51+08:00">2019-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 17:35:43" itemprop="dateModified" datetime="2022-11-15T17:35:43+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们在看qt源码中总能找到一个d指针，在这里记录一下d指针、d_func()的作用，以QWidget为例来介绍一下d指针和d_func()的实现方式</p>
<p>在qglobal.h头文件中我们能找到以下定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//qglobal.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">static</span> <span class="keyword">inline</span> T *<span class="title">qGetPtrHelper</span><span class="params">(T *ptr)</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Wrapper&gt; <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">typename</span> Wrapper::pointer <span class="title">qGetPtrHelper</span><span class="params">(<span class="type">const</span> Wrapper &amp;p)</span> </span>&#123; <span class="keyword">return</span> p.<span class="built_in">data</span>(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> Class##<span class="function">Private* <span class="title">d_func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;Class##Private *&gt;(<span class="built_in">qGetPtrHelper</span>(d_ptr)); &#125; \</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">const</span> Class##<span class="function">Private* <span class="title">d_func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> Class##Private *&gt;(<span class="built_in">qGetPtrHelper</span>(d_ptr)); &#125; \</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Class</span>##Private;</span><br></pre></td></tr></table></figure>

<p>以下是QWidget头文件和源文件，这里只截取关键部分，并使用宏定义将其替换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QWidget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Q_WIDGETS_EXPORT</span> QWidget : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QPaintDevice</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="built_in">Q_DECLARE_PRIVATE</span>(QWidget)</span><br><span class="line">    <span class="comment">// 将 Q_DECLARE_PRIVATE 替换后</span></span><br><span class="line">    <span class="comment">//d_func() 作用是获取 QWidget 中继承的 QObject 中的 QObjectData 指针，并使用强制类型转换为 QWidgetPrivate 指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> QWidgetPrivate* <span class="title">d_func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;QWidgetPrivate *&gt;(<span class="built_in">qGetPtrHelper</span>(d_ptr)); &#125; \</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> QWidgetPrivate* <span class="title">d_func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> QWidgetPrivate *&gt;(<span class="built_in">qGetPtrHelper</span>(d_ptr)); &#125; \</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">QWidgetPrivate</span>;</span><br><span class="line">    <span class="comment">//Class##Private 中##是将两个字符串拼接在一起</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:        </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QWidget</span><span class="params">(QWidget* parent = Q_NULLPTR, Qt::WindowFlags f = Qt::WindowFlags())</span></span>;</span><br><span class="line">    ~<span class="built_in">QWidget</span>();       </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">QWidget</span>(QWidgetPrivate &amp;d, QWidget* parent, Qt::WindowFlags f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//QWidget.cpp</span></span><br><span class="line"><span class="comment">//这个构造函数是我们外部可以调用的构造函数，</span></span><br><span class="line">QWidget::<span class="built_in">QWidget</span>(QWidget *parent, Qt::WindowFlags f)</span><br><span class="line">    : <span class="built_in">QObject</span>(*<span class="keyword">new</span> QWidgetPrivate, <span class="number">0</span>), <span class="comment">//在这new QWidgetPrivate类，给QObject类,QWidgetPrivate 是QWidget的内部类</span></span><br><span class="line">	<span class="built_in">QPaintDevice</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="built_in">d_func</span>()-&gt;<span class="built_in">init</span>(parent, f);	<span class="comment">//在这里调用,调用了QWidgetPrivate类的内部方法</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QWidget内部构造函数</span></span><br><span class="line">QWidget::<span class="built_in">QWidget</span>(QWidgetPrivate &amp;dd, QWidget* parent, Qt::WindowFlags f)</span><br><span class="line">    : <span class="built_in">QObject</span>(dd, <span class="number">0</span>), <span class="built_in">QPaintDevice</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(QWidget);</span><br><span class="line">    <span class="comment">//将Q_D替换后</span></span><br><span class="line">    QWidgetPrivate * <span class="type">const</span> d = <span class="built_in">d_func</span>()</span><br><span class="line">	...</span><br><span class="line">    d-&gt;<span class="built_in">init</span>(parent, f);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到 qGetPtrHelper(d_ptr)中调用了 d_ptr，这个指针是哪里来的，在QObject.h中，声明了d_ptr成员变量，QScopedPointer是一个智能指针，类似与C++11中的std::unique_ptr，因为在QT中所有的类的基类都是QObejct</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QObejct.h</span></span><br><span class="line"><span class="keyword">protected</span>:	<span class="comment">//注意这里是protected，那么QWidget继承方式是public，所以d_ptr是可以直接使用的</span></span><br><span class="line">    QScopedPointer&lt;QObjectData&gt; d_ptr;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/15/c-11%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/15/c-11%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">c++11实现线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-15 17:04:33" itemprop="dateCreated datePublished" datetime="2019-05-15T17:04:33+08:00">2019-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 17:08:44" itemprop="dateModified" datetime="2022-11-15T17:08:44+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>一般而言,线程池有以下几个部分:</p>
<p>完成主要任务的一个或多个线程。<br>用于调度管理的管理线程。<br>要求执行的任务队列。<br>简单来说就是线程过多会带来调度开销，进而影响缓存局部性和整体性能，而线程池维护着多个线程，等待管理者分配并发这姓的任务，从而避免了在处理短时间任务时创建与销毁线程的代价，线程池不仅能保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络等的数量</p>
<h1 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h1><p>创建一定数量的线程，启动线程，调配任务，管理着线程池</p>
<p>代码中主要使用功能</p>
<p>在构造创建创建一定数量的线程池,进行线程循环<br>stop(void)停止所有线程循环，回收所有资源<br>add_task()和 &lt;&lt; 添加一个任务，添加任务的时候可以使用lambda表达式</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_pool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//在构造中创建一定数量(threadnums)的线程  </span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">thread_pool</span><span class="params">(std::<span class="type">size_t</span> threadnums)</span></span>;</span><br><span class="line">  <span class="comment">//析构</span></span><br><span class="line">  ~<span class="built_in">thread_pool</span>(<span class="type">void</span>);</span><br><span class="line">  <span class="comment">//拷贝构造</span></span><br><span class="line">  <span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">//赋值运算符</span></span><br><span class="line">  thread_pool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> thread_pool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//定义一个没有参数的函数指针类型</span></span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; <span class="type">task_t</span>;</span><br><span class="line">  <span class="comment">//像线程池队列中添加一个任务</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_task</span><span class="params">(<span class="type">const</span> <span class="type">task_t</span>&amp; task)</span></span>;</span><br><span class="line">  <span class="comment">//重载&lt;&lt;操作符，和add_task功能一样</span></span><br><span class="line">  thread_pool&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> <span class="type">task_t</span>&amp; task);</span><br><span class="line">  <span class="comment">//停止线程池，并等待工作中的线程执行完成</span></span><br><span class="line">  <span class="comment">//如果某些任务处于挂起状态，则不会执行这些任务</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//返回线程池是否在运行</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_running</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//重置线程池中的数量</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_nb_threads</span><span class="params">(std::<span class="type">size_t</span> nb_threads)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//线程函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">  <span class="comment">//从任务队列里获取一个新的任务</span></span><br><span class="line">  <span class="function">std::pair&lt;<span class="type">bool</span>, <span class="type">task_t</span>&gt; <span class="title">fetch_task_or_stop</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">  <span class="comment">//判断线程是否停止</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">should_stop</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//工作线程列表</span></span><br><span class="line">  std::list&lt;std::thread&gt; m_workers;</span><br><span class="line">  <span class="comment">//允许创建的最大线程数量</span></span><br><span class="line">  std::atomic&lt;std::<span class="type">size_t</span>&gt; m_max_nb_threads = <span class="built_in">ATOMIC_VAR_INIT</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//当前正在运行的线程数</span></span><br><span class="line">  std::atomic&lt;std::<span class="type">size_t</span>&gt; m_nb_running_threads = <span class="built_in">ATOMIC_VAR_INIT</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//线程是否应该停止</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; m_should_stop = <span class="built_in">ATOMIC_VAR_INIT</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">//任务队列</span></span><br><span class="line">  std::queue&lt;<span class="type">task_t</span>&gt; m_tasks;</span><br><span class="line">  <span class="comment">//互斥锁</span></span><br><span class="line">  std::mutex m_tasks_mtx;</span><br><span class="line">  <span class="comment">//条件变量</span></span><br><span class="line">  std::condition_variable m_tasks_condvar;</span><br><span class="line">&#125;;</span><br><span class="line">thread_pool::<span class="built_in">thread_pool</span>(std::<span class="type">size_t</span> nb_threads)</span><br><span class="line">&#123;</span><br><span class="line">  	std::cout &lt;&lt; <span class="string">&quot;create thread_pool&quot;</span>;</span><br><span class="line">  	<span class="built_in">set_nb_threads</span>(nb_threads);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread_pool::~<span class="built_in">thread_pool</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;destroy thread_pool&quot;</span>;</span><br><span class="line">  	<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::run</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;start run() worker&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> res     = <span class="built_in">fetch_task_or_stop</span>();</span><br><span class="line">    <span class="type">bool</span> stopped = res.first;</span><br><span class="line">    <span class="type">task_t</span> task  = res.second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止线程</span></span><br><span class="line">    <span class="keyword">if</span> (stopped) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task) &#123;</span><br><span class="line">      std::cout &lt;&lt;<span class="string">&quot;execute task&quot;</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp;)</span><br><span class="line">      &#123;</span><br><span class="line">          std::cout &lt;&lt;<span class="string">&quot;uncatched exception propagated up to the threadpool.&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      std::cout &lt;&lt;<span class="string">&quot;execution complete&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt;<span class="string">&quot;stop run() worker&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::stop</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (!<span class="built_in">is_running</span>()) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">  	m_should_stop = <span class="literal">true</span>;</span><br><span class="line">  	m_tasks_condvar.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">//等待所有在执行任务的线程执行完毕</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : m_workers) &#123; worker.<span class="built_in">join</span>(); &#125;</span><br><span class="line">  	m_workers.<span class="built_in">clear</span>();</span><br><span class="line">  	std::cout &lt;&lt; <span class="string">&quot;thread_pool stopped&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">thread_pool::is_running</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !m_should_stop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">thread_pool::should_stop</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m_should_stop || m_nb_running_threads &gt; m_max_nb_threads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">bool</span>, thread_pool::<span class="type">task_t</span>&gt; <span class="title">thread_pool::fetch_task_or_stop</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_tasks_mtx)</span></span>;</span><br><span class="line"> 	std::cout &lt;&lt; <span class="string">&quot;waiting to fetch task&quot;</span>;</span><br><span class="line">    <span class="comment">//等待唤醒，并且 有任务增加或线程停止</span></span><br><span class="line">  	m_tasks_condvar.<span class="built_in">wait</span>(lock, [&amp;] &#123; <span class="keyword">return</span> <span class="built_in">should_stop</span>() || !m_tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">  	<span class="keyword">if</span> (<span class="built_in">should_stop</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    	--m_nb_running_threads;</span><br><span class="line">    	<span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">task_t</span> task = std::<span class="built_in">move</span>(m_tasks.<span class="built_in">front</span>());</span><br><span class="line">  m_tasks.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="literal">false</span>, task&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这里并没有定义队列的大小，如果有需求再增加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::add_task</span><span class="params">(<span class="type">const</span> <span class="type">task_t</span>&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_tasks_mtx)</span></span>;</span><br><span class="line"> 	std::cout &lt;&lt; <span class="string">&quot;add task to thread_pool&quot;</span>;</span><br><span class="line">    <span class="comment">//添加任务到消息队列中</span></span><br><span class="line">  	m_tasks.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="comment">//唤醒等待获取任务的线程进行工作</span></span><br><span class="line">  	m_tasks_condvar.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">thread_pool&amp; thread_pool::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> <span class="type">task_t</span>&amp; task) &#123;</span><br><span class="line">  <span class="built_in">add_task</span>(task);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::set_nb_threads</span><span class="params">(std::<span class="type">size_t</span> nb_threads)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_max_nb_threads = nb_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果正在运行的线程数小于最大线程数量，则创建线程，并设置启动函数run,将线程添加到线程列表中管理</span></span><br><span class="line">  <span class="keyword">while</span> (m_nb_running_threads &lt; m_max_nb_threads) &#123;</span><br><span class="line">	  ++m_nb_running_threads;</span><br><span class="line">	  m_workers.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;thread_pool::run, <span class="keyword">this</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果大于最大线程数量，则唤醒线程使其停止</span></span><br><span class="line">  <span class="keyword">if</span> (m_nb_running_threads &gt; m_max_nb_threads) &#123;</span><br><span class="line">	  m_tasks_condvar.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/04/01/async%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/01/async%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">async方法使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-01 16:59:38" itemprop="dateCreated datePublished" datetime="2019-04-01T16:59:38+08:00">2019-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 17:03:48" itemprop="dateModified" datetime="2022-11-15T17:03:48+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><p>std::async函数原型如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( Function&amp;&amp; f, Args&amp;&amp;... args );</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">invoke_result_t</span>&lt;std::<span class="type">decay_t</span>&lt;Function&gt;,</span><br><span class="line">                                 std::<span class="type">decay_t</span>&lt;Args&gt;...&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( Function&amp;&amp; f, Args&amp;&amp;... args );</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args );</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">std::future&lt;std::<span class="type">invoke_result_t</span>&lt;std::<span class="type">decay_t</span>&lt;Function&gt;,</span><br><span class="line">                                 std::<span class="type">decay_t</span>&lt;Args&gt;...&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args );</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br></pre></td></tr></table></figure>

<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><p>std::async是对异步编程的高级封装，封装了sd::future的操作，基本是上可以代替std::thread的操作，这里代替并不是盲目的代替，需要根据具体场景来使用</p>
<p>std::future可以从异步任务中获取结果，一般与std::async配合使用，std::async用于创建同步&#x2F;异步任务，实际上就是创建一个线程执行相应任务</p>
<p>std::async中Function接受一个可调用的对象(仿函数、lambda表达式、、类成员函数、普通函数等)作为参数,并且异步或是同步执行他们</p>
<p>std::launch 是执行策略，由一下集中情况：</p>
<ul>
<li>std::launch::async 传递的可调用对象异步执行</li>
<li>std::launch::deferred 传递的可调用对象同步执行</li>
<li>std::launch::async | std::launch::deferred 可以异步或是同步，取决于操作系统，我们无法控制</li>
<li>如果我们不指定策略，则相当于3</li>
</ul>
<p>对于执行结果我们可以使用get、wait、wait_for、wait_until等待执行结束，区别是get可以获得执行的结果。如果选择异步执行策略，调用get时，如果异步执行没有结束，get会阻塞当前调用线程，直到异步执行结束并获得结果，如果异步执行已经结束，不等待获取执行结果；如果选择同步执行策略，只有当调用get函数时，同步调用才真正执行，这也被称为函数调用被延迟。</p>
<p>返回结果std::future的状态：</p>
<p>deffered：异步操作还没有开始<br>ready：异步操作已经完成<br>timeout：异步操作超时</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="function">std::string <span class="title">ProcessData1</span><span class="params">(std::string recvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ProcessData1 Start&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ProcessData1_&quot;</span> + recvData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">ProcessData2</span><span class="params">(string recvData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ProcessData2 start&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ProcessData1_&quot;</span>+ recvData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main start&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//计时</span></span><br><span class="line">    system_clock::time_point start = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    future&lt;string&gt; resultProcessData1 = <span class="built_in">async</span>(launch::async, ProcessData1, <span class="string">&quot;async1&quot;</span>);</span><br><span class="line">    future&lt;string&gt; resultProcessData2 = <span class="built_in">async</span>(launch::deferred, ProcessData2, <span class="string">&quot;async2&quot;</span>);</span><br><span class="line">    <span class="comment">//当设置为同步，直到get函数执行才开始执行任务</span></span><br><span class="line">    string resultData2 = resultProcessData2.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注释行是使用第二种方法wait_for，通过判断future_status状态来获取执行结果</span></span><br><span class="line"><span class="comment">//    future_status status;</span></span><br><span class="line"><span class="comment">//    string strData;</span></span><br><span class="line"><span class="comment">//    do</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        status = resultProcessData1.wait_for(chrono::seconds(1));</span></span><br><span class="line"><span class="comment">//        switch (status)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//        case future_status::ready:</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; &quot;Ready&quot; &lt;&lt; endl;    		  </span></span><br><span class="line"><span class="comment">//            strData = resultProcessData1.get();</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; strData &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        case future_status::timeout:</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; &quot;time out&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        case future_status::deferred:</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; &quot;deferred&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        default:</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;while(status != future_status::ready);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果ProcessData1没有执行完成，则get会阻塞</span></span><br><span class="line">    string resultData1 = resultProcessData1.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印耗时时间</span></span><br><span class="line">    <span class="keyword">auto</span> end = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> diff = <span class="built_in">duration_cast</span>&lt;chrono::seconds&gt;(end -start).<span class="built_in">count</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total Time Token = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot;Seconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">    string data = resultData1 + <span class="string">&quot;::&quot;</span> + resultData2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;data = &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面贴出cppreference的示例代码</p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/async">https://en.cppreference.com/w/cpp/thread/async</a></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parallel_sum</span><span class="params">(RandomIt beg, RandomIt end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> len = end - beg;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(beg, end, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    RandomIt mid = beg + len/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> handle = std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                             parallel_sum&lt;RandomIt&gt;, mid, end);</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">parallel_sum</span>(beg, mid);</span><br><span class="line">    <span class="keyword">return</span> sum + handle.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum is &quot;</span> &lt;&lt; <span class="built_in">parallel_sum</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    X x;</span><br><span class="line">    <span class="comment">// Calls (&amp;x)-&gt;foo(42, &quot;Hello&quot;) with default policy:</span></span><br><span class="line">    <span class="comment">// may print &quot;Hello 42&quot; concurrently or defer execution</span></span><br><span class="line">    <span class="keyword">auto</span> a1 = std::<span class="built_in">async</span>(&amp;X::foo, &amp;x, <span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="comment">// Calls x.bar(&quot;world!&quot;) with deferred policy</span></span><br><span class="line">    <span class="comment">// prints &quot;world!&quot; when a2.get() or a2.wait() is called</span></span><br><span class="line">    <span class="keyword">auto</span> a2 = std::<span class="built_in">async</span>(std::launch::deferred, &amp;X::bar, x, <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    <span class="comment">// Calls X()(43); with async policy</span></span><br><span class="line">    <span class="comment">// prints &quot;43&quot; concurrently</span></span><br><span class="line">    <span class="keyword">auto</span> a3 = std::<span class="built_in">async</span>(std::launch::async, <span class="built_in">X</span>(), <span class="number">43</span>);</span><br><span class="line">    a2.<span class="built_in">wait</span>();                     <span class="comment">// prints &quot;world!&quot;</span></span><br><span class="line">    std::cout &lt;&lt; a3.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints &quot;53&quot;</span></span><br><span class="line">&#125; <span class="comment">// if a1 is not done at this point, destructor of a1 prints &quot;Hello 42&quot; here</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/03/10/C-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午饭吃啥">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/10/C-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">C++强制类型转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-10 16:33:07" itemprop="dateCreated datePublished" datetime="2019-03-10T16:33:07+08:00">2019-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-15 16:51:54" itemprop="dateModified" datetime="2022-11-15T16:51:54+08:00">2022-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++通过引进四个新的类型转换操作符克服了 C 风格类型转换的缺点，这四个操作符是, static_cast, const_cast, dynamic_cast, 和 reinterpret_cast**。在大多数情况下，对于<br>这些操作符你只需要知道原来你习惯于这样写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type) expression</span><br></pre></td></tr></table></figure>
<p>而现在你应该这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure>

<p>例如，假设你想把一个 int 转换成 double，以便让包含 int 类型变量的表达式产生出浮点数值的结果。</p>
<p>如果用 C 风格的类型转换，应该这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> firstNumber, secondNumber;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> result = ((<span class="type">double</span>)firstNumber)/secondNumber；</span><br></pre></td></tr></table></figure>
<p>如果用上述新的类型转换方法，应该这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(firstNumber)/secondNumber;</span><br></pre></td></tr></table></figure>
<p>这样的类型转换不论是对人工还是对程序都很容易识别。</p>
<h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast  "></a>static_cast  </h1><p>static_cast 在功能上基本上与 C 风格的类型转换一样强大，含义也一样。它也有功能上限制。例如，你不能用</p>
<p>static_cast 象用 C 风格的类型转换一样把 struct 转换成 int 类型或者把 double 类型转换成指针类型，不能从表达</p>
<p>式中去除 const 属性，因为另一个新的类型转换操作符 const_cast 有这样的功能</p>
<p>static_cast主要作用</p>
<ul>
<li><p>该函数主要用于基本类型之间和具有继承关系的类型之间的转换</p>
</li>
<li><p>这种转换一般会更改变量的内部表示方式，因此，static_cast应用于指针类型转换没有太大意义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本类型转换</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i); <span class="comment">//等价于 double d = (double)i;</span></span><br><span class="line"><span class="comment">//转换继承类的对象为基类对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base b = <span class="built_in">static_cast</span>&lt;Base&gt;(d); <span class="comment">//等价于 Base b = (Base)d;</span></span><br></pre></td></tr></table></figure>
<h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1></li>
</ul>
<p>const_cast 用于类型转换掉表达式的 const 或 volatileness 属性。通过使用 const_cast，你向人们和编译器强调你通过类型转换想做的只是改变一些东西的 constness 或者 volatileness 属性。这个含义被编译器所约束。如果你试图使用 const_cast 来完成修改 constness 或者 volatileness 属性之外的事情，你的类型转换将被拒绝</p>
<p>const_cast主要作用</p>
<ul>
<li><p>该函数用于去除指针变量的常量属性，将它转换为一个对应指针类型的普通变量。反过来，也可以将一个非常量的指针变量转换为一个常指针变量</p>
</li>
<li><p>这种转换是在编译期间做出的类型更改</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* pci = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* pk = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(pci); <span class="comment">//等价于int* pk = (int*)pci;</span></span><br><span class="line"><span class="type">const</span> A* pca = <span class="keyword">new</span> A;</span><br><span class="line">A* pa = <span class="built_in">const_cast</span>&lt;A*&gt;(pca); <span class="comment">//等价于A* pa = (A*)pca;</span></span><br></pre></td></tr></table></figure>
<p>出于安全性考虑，const_cast无法将非指针的常量转换为普通变量。</p>
<h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p>reinterpret_cast主要作用</p>
<ul>
<li><p>该函数将一个类型的指针转换为另一个类型的指针 .</p>
</li>
<li><p>这种转换不用修改指针变量值存放格式(不改变指针变量值),只需在编译时重新解释指针的类型就可做到.</p>
</li>
<li><p>reinterpret_cast可以将指针值转换为一个整型数,但不能用于非指针类型的转换。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本类型指针的类型转换</span></span><br><span class="line"><span class="type">double</span> d=<span class="number">9.2</span>;</span><br><span class="line"><span class="type">double</span>* pd = &amp;d;</span><br><span class="line"><span class="type">int</span> *pi = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(pd); <span class="comment">//相当于int *pi = (int*)pd;</span></span><br><span class="line"><span class="comment">//不相关的类的指针的类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line">A* pa = <span class="keyword">new</span> A;</span><br><span class="line">B* pb = <span class="built_in">reinterpret_cast</span>&lt;B*&gt;(pa); <span class="comment">//相当于B* pb = (B*)pa;</span></span><br><span class="line"><span class="comment">//指针转换为整数</span></span><br><span class="line"><span class="type">long</span> l = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span>&gt;(pi); <span class="comment">//相当于long l = (long)pi;</span></span><br></pre></td></tr></table></figure>

<h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>它被用于安全地沿着类的继承关系向下进行类型转换。这就是说，你能用 dynamic_cast 把指向基类的指针或引用转换成指向其派生类或其兄弟类的指针或引用，而且你能知道转换是否成功。失败的转换将返回空指针（当对<br>指针进行类型转换时）或者抛出异常(当对引用进行类型转换时)dynamic_casts 在帮助你浏览继承层次上是有限制的。它不能被用于缺乏虚函数的类型上，也不能用它来转换掉 constness</p>
<p>dynamic_cast主要作用</p>
<ul>
<li>它与static_cast相对，是动态转换。</li>
<li>这种转换是在运行时进行转换分析的，并非在编译时进行，明显区别于上面三个类型转换操作。</li>
<li>该函数只能在继承类对象的指针之间或引用之间进行类型转换。进行转换时，会根据当前运行时类型信息，判断类型对象之间的转换是否合法。dynamic_cast的指针转换失败，可通过是否为null检测，引用转换失败则抛出一个bad_cast异常。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="comment">//派生类指针转换为基类指针</span></span><br><span class="line">Derived *pd = <span class="keyword">new</span> Derived;</span><br><span class="line">Base *pb = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(pd);</span><br><span class="line"> <span class="keyword">if</span> (!pb)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类型转换失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有继承关系，但被转换类有虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">A</span><span class="params">(<span class="keyword">virtual</span> ~A();)</span> <span class="comment">//有虚函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> B</span>&#123;&#125;:</span><br><span class="line">A* pa = <span class="keyword">new</span> A;</span><br><span class="line">B* pb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dc</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
